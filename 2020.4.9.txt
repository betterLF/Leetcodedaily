933. 最近的请求次数
本题无问题。
641. 设计循环双端队列
双端队列是由两个队列构成的
两个队列其实是向内的(1)->(2)(3)<-(4)
insertFront()：将一个元素添加到双端队列头部,即加到（1）处。
insertLast()：将一个元素添加到双端队列尾部。即加到（4）处。
deleteFront()：从双端队列头部删除一个元素。即删除（1）处，如果左边队列为空，就删除（3）处，因此这题用ArrayDeque类（有删除首尾元素的功能）
deleteLast()：从双端队列尾部删除一个元素。即删除（4）处，如果右边队列为空，就删除（2）处。
getFront()：从双端队列头部获得一个元素。即（1）处。
getRear()：获得双端队列的最后一个元素。 即(4)处。
面试题 17.09. 第 k 个数
这题是用三指针的动态规划来做
分析：第k个数是指第k小的数吧?这个题目应该是剑指offer或编程之美中的丑数。
(来源于他人博客：https://blog.csdn.net/qingyuanluofeng/article/details/54124669)
      丑数的关键是寻找下一个丑数，
	  下一个丑数 = 在之前生成的丑数数组中寻找一个数 * (3或5或7)，即大于当前丑数的最小值
	  设当前丑数为M
	  设第一个乘以3大于M的数为M3，同理M5,M7,则M = min(M3, M5 , M7)
	  对于丑数3而言，必定存在T3使得T3之前的数乘以3都小于M,T3之后的丑数
	  关键是寻找丑数数组中第一个乘以3大于当前最大丑数的数T3,寻找丑数数组中第一个乘以5大于最大丑数的数T5,同理T7
	  使得：
	  设当前丑数为M
	  3*T3=M3 > M  【公式(1)】
	  5*T5=M5 > M  【公式(2)】
	  7*T7=M7 > M  【公式(3)】
	  从中令新的M = min(M3 , M5 , M7)，并更新T3,T5,T7，使得新的T3,有3*T3 > M，同理T5,T7    【操作1】
	  如果不更新，带来的问题就是，会陷入死循环
	  比如刚开始M=1,初始T3=T5=T7=1,满足上述条件后，M=3,此时3*T3 <= M,则T3=1没有等于3,同理后续T5=1,T7=1,而M=7,
	  之后就发现T3,T5,T7中没有一个能符合上述公式(1),(2),(3)，则M一直变成7不再变化；
621. 任务调度器（来源于leetcode官方）链接：https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode/
1：排序+贪心
由于相同的任务之间必须有 n 的冷却时间，所以我们可以想到按照任务的数量来安排它们，即一种任务的出现次数越多，我们就越早地安排。例如有 5 种任务 A, B, C, D, E，且它们分别有 6, 1, 1, 1, 1 个时，假设冷却时间 n = 2，那么我们首先安排任务 A，随后在 2 单位的冷却时间里，我们安排任务 B, C，随后继续安排任务 A，再安排任务 D, E，以此类推。
因此我们得到了一种安排的方法：我们规定 n + 1 个任务为一轮，这样的好处是同一轮中一个任务最多只能被安排一次。在每一轮中，我们将当前的任务按照它们剩余的次数降序排序，并选择剩余次数最多的 n + 1 个任务依次执行。如果任务的种类 t 少于 n + 1 个，就只选择全部的 t 种任务，其余的时间空闲。这样做的正确性在于，由于冷却时间的存在，出现次数较多的那些任务如果不尽早安排，将会导致大量空闲时间的出现，因此贪心地将出现次数较多的任务安排在前面是合理的。同时我们可以保证，这一轮的第 k 个任务距离上一次执行至少有 n 个单位的冷却时间。我们可以使用逆向思维来证明：假设第 r 轮中某个任务在第 k 个执行，那么说明它在第 r 轮时为数量第 k 多的任务。在第 r 轮结束后，第 1 多到第 k 多的任务的数量都会减少 1，因此在第 r + 1 轮，这个任务最多也只能是数量第 k 多，因此它如果被执行，一定满足冷却时间的要求。
根据上面的安排方法，我们每一轮选择不超过 n + 1 个任务执行，直到所有的任务被执行。
3：设计
在前两种方法中，我们了解到应当尽早安排出现次数较多的任务。我们假设 A 为出现次数最多的任务，假设其出现了 p 次，考虑到冷却时间，那么执行完所有任务的时间至少为 (p - 1) * (n + 1) + 1。我们把这个过程形象化地用图 1 表现出，可以发现，CPU 产生了 (p - 1) * n 个空闲时间，只有 p 个时间是在工作的。
因此我们应当考虑把剩余的任务安排到这些空闲时间里，我们仍然按照这些任务的出现次序，从大到小进行安排，会有下面三种情况：
某个任务和 A 出现的次数相同，例如图 2 中的任务 B。此时我们只能让 B 占据 p - 1 个空闲时间，而在非空闲时间里额外安排一个时间给 B 执行；
某个任务比 A 出现的次数少 1，例如图 2 中的任务 C。此时我们可以让 C 占据 p - 1 个空闲时间，就可以全部执行完；
某个任务比 A 出现的次数少 2 或更多，例如图 2 中的任务 D。此时我们可以按照列优先的顺序，将 D 填入空闲时间中。因为 D 出现的次数少于 p - 1，因此无论从哪个位置开始按照列优先的顺序放置，都可以保证相邻的两个 D 之间满足冷却时间的要求。
在将所有的任务安排完成后，如果仍然有剩余的空闲时间，那么答案即为（任务的总数 + 剩余的空闲时间）；如果在安排某一个任务时，遇到了剩余的空闲时间不够的情况，那么答案一定就等于任务的总数。这是因为我们可以将空闲时间增加虚拟的一列，继续安排任务。如果不考虑这些虚拟的列，在原本空闲时间对应的那些列中的任务是可以按照要求顺序执行的，而增加了这些虚拟的列后，两个相邻的相同任务的间隔不可能减少，并且虚拟的列中的任务也满足冷却时间的要求，因此仍然顺序执行并跳过虚拟的列中剩余的“空闲时间”一定是可行的。
链接：https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode/


