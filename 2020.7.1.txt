221. 最大正方形
遍历整个数组，如果当前最大正方形长度为max，则row-i<=max,退出最外层循环，column-j<=max，退出最里层循环（因为此时无论如何都不可能超过max）,否则如果值为1，进行遍历，先是判断是否可以边长为2,(先竖再横判断)，可以的话继续往后判断是否可以为3,4....最后更新max值，继续遍历即可
5448. 判断路径是否相交
将每一轮的结果加入hashmap中，key存放横坐标，value存放所有纵坐标，遍历字符串，得到x和y坐标进行判断即可
5449. 检查数组对是否可以被 k 整除
先对所有数取余并计算余数出现次数(如果余数为负数则+k),i!=0时此时如果nums[i]和nums[k-i]不等，则不能全部匹配，直接返回false，如果nums[0]不为偶数，直接返回false，否则返回true
5450. 满足条件的子序列数目
先对数组排序，然后双指针遍历，找到此时下标i满足条件的最大j值，此时以i为开头的剩余数组长度为0-j-i，这是二项求和，结果为2的j-i次方，但java中超过2的64次方-1就出现精度问题，所以用    int mode = 1000000007; for (int i = 1; i < nums.length; i ++) {pow[i] = pow[i-1] * 2;pow[i] %= mode;}来求取即可，最后如果j指针大于i指针，退出遍历即可
