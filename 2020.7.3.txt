240. 搜索二维矩阵 II
从左下角开始，如果当前元素大于目标值，则行数上移，如果当前元素值小于目标值，则列数右移即可，直到直到结果或者行列超出范围即可
264. 丑数 II
定义长度为n的数组，并且num[0]=1，然后定义三个指针p1，p2，p3,初始化都为0，从i开始遍历数组，每轮的num[i]=num[p1]*2,num[p2]*3,num[p3]*5的最小值，然后如果num[i]=num[p1]*2,p1后移，其余两个都进行判断(防止出现比较的三个值中出现相同的情况)，这样的正确性是所有的丑数都是有前面一个丑数*2，*3，*5得到的，而假设num[p1]*2已经出现了，后面就没必要拿它*2比了，应该找到下一个丑数(*2）加入下轮比较
274. H 指数
1.排序：将数组进行降序排列，由于Arrays.sort(）是升序排序，所以遍历时倒着来。只要当前论文的引用量大于i，则i++，最后返回i即可。
2：计数:新建一个数组num，遍历原数组，如果当前值大于等于n，则num[n]++，否则num[cur]++，然后从i=n开始，记录此时已经引用的论文数量，如果count>=i,就返回i，否则返回0
275. H指数 II
二分搜索，如果当前中间值等于数组长度-mid，则直接返回，因为此时无论往前走(论文引用数量减少)还是往后(论文数量减少)走都无法超过该值，如果小于数组长度-mid，则left=mid+1，比如citations[mid]=2，len-mid=4，则可能还存在一个更大的值满足条件，所以往后走，同理，大于数组长度-mid，则right=mid-1。退出循环后返回数组长度-left。