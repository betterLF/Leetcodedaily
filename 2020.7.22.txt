441. 排列硬币
二分搜索+等差数列求和
如果left<=right，while循环，得到中间值对应的等差数列值，如果值大于n，right=mid-1，如果值小于n，left=mid+1，否则返回mid，最后返回left-1。
5464. 换酒问题
只要当前酒瓶数不为0，就一直while循环，每一次循环ans++，当前酒瓶数--，此时cur++，如果cur=可以换酒的空瓶数，则当前酒瓶数++，cur=0，继续
5465. 子树中标签相同的节点数
将二维数组都放入hashmap中，key存放结点，value存放相邻的边。
从0开始dfs遍历，将当前点标记为已遍历，遍历该点的所有边，如果该点没有遍历过，就遍历该点，将该点的结果数组加入当前点的一个集合中(存放每个子树的字母出现情况)，然后结束后遍历该集合，得到一个以该点为根节点得到的字母情况并且将该结点对应值++，然后把该点的结果放入结果数组即可。
5466. 最多的不重叠子字符串
定义一个二维数组，存放每个元素出现的首尾位置，然后对于每个字母出现的首位置开始遍历到末位置，如果在这过程中碰到一个字符的开始字段在该字符之前就break，否则末位置更新，如果遍历到最后，则字符该位置能组成满足字符的末位置为max(即该字符开始位置对应的结束位置是max，此时满足条件)，然后字符串从后往前遍历，只要当前位置的末位置在当前结尾之前就加入结果集，然后更新末位置，继续往前遍历，最后返回结果
