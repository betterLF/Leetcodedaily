34. 在排序数组中查找元素的第一个和最后一个位置
对有序数组进行两次二分查找，分别找左边界和右边界即可
36. 有效的数独
定义三个9*9的二维数组，分别代表行，列，组，二维数组的行下标代表元素值-1(如1的行下标为0)，遍历数组，如果当前行数和列数的值出现过，就返回false，否则将该位置的行数组和列数组置为1，至于组别，每个元素所在的组为j/3*3+i/3;同理进行判断即可。
43. 字符串相乘
定义结果数组，长度为两字符串长度之和。然后两个从后往前的for循环遍历，每次第二层for循环求解第二个元素的当前末尾元素与第一个元素的乘积，每算一位加到当前结果集的位置，如果此时位置上的元素大于10，进位C=当前值/10，当前值%=10,第二层for结束后，如果进位不为0，就继续加下一位。然后将下一次加入结果集的起始位置前移，两层for循环结束后，从结果集不为0的第一个元素开始加入StringBuilder中即可
46. 全排列
定义结果，Integer数组，boolean数组为全局变量，初始化两个数组长度为nums的长度，然后调用回溯函数，参数为当前要赋值的下标index以及原数组，如果index=当前数组长度，直接将当前Integer数组加入结果集 ，ans.add(new ArrayList<>(Arrays.asList(temp)));否则遍历数组，只要flag[i]=true,代表访问过就继续遍历，否则当前Integer的index位置赋值给当前元素并且flag[i]=true,进行下一个位置的回溯，回溯结束后将该位置flag[i]置为false即可。
