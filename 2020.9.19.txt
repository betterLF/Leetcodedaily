672. 灯泡开关 Ⅱ
因为前 6 个灯唯一地决定了其余的灯。这是因为修改第 xx 灯光的每个操作都会修改 第 (x+6)(x+6) 灯光，因此 xx 灯光始终等于 (x+6)(x+6) 灯光。
实际上，前 3 个灯唯一地确定了序列的其余部分，如下表所示，用于执行操作 a, b, c, d:
Light 1 = 1 + a + c + d
Light 2 = 1 + a + b
Light 3 = 1 + a + c
Light 4 = 1 + a + b + d
Light 5 = 1 + a + c
Light 6 = 1 + a + b
上述理由表明，在不损失一般性的情况下，取 n = min(n, 3)n=min(n,3) 是合理的。
让我们用 (a, b, c)(a,b,c) 来表示灯的状态。与值为 (1, 1, 1), (0, 1, 0), (1, 0, 1),(1,1,1),(0,1,0),(1,0,1), (1, 0, 0)(1,0,0) xor.
当 m=0m=0 时，所有灯都亮起，只有一个状态 (1, 1, 1)(1,1,1)。在这种情况下，答案总是 1。
当 m=1m=1 时，我们可以得到状态 (0, 0, 0)(0,0,0), (1, 0, 1)(1,0,1), (0, 1, 0)(0,1,0), (0, 1, 1)(0,1,1)。在这种情况下，对于 n = 1, 2, 3n=1,2,3 的答案是 2, 3, 42,3,4。
当 m=2m=2 时，我们可以检查是否可以获得 7 个状态：除(0, 1, 1)(0,1,1)之外的所有状态。在这种情况下，n = 1, 2, 3n=1,2,3 的答案是 2, 4, 72,4,7。
当 m=3m=3 时，我们可以得到所有 8 个状态。在这种情况下，n = 1, 2, 3n=1,2,3 的答案是 2, 4, 82,4,8

673. 最长递增子序列的个数
动态规划，length数组记录以当前位置为结尾的最长递增子序列长度，count记录当前位置最长递增子序列的个数，双层for循环遍历数组，如果nums[i]<nums[j]，则对length进行判断如果i的length大于等于j的，则j的length更新为i的+1，并且其count和i的count一样，如果j的length=i的length+1，则j的count+=i的count即可。最后遍历length数组找到最长的并将所有最长的个数加起来即可。

676. 实现一个魔法字典
用哈希表存放，key存放长度，value存放该长度的字符串，查找元素时只在长度相同的里面找，如果找不到返回false，否则返回true。