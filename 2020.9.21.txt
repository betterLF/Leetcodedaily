688. “马”在棋盘上的概率
方法1:动态规划，即令 f[r][c][steps] 代表马在位置 (r, c) 移动了 steps 次以后还留在棋盘上的概率，根据马的移动方式，我们有以下递归：
f[r][c][steps]= dr,dc∑f[r+dr][c+dc][steps−1]/8.0
根据题目我们可以知道 (dr, dc)(dr,dc) 的可能数据对是 (2, 1),(2,1), (2, -1),(2,−1), (-2, 1),(−2,1), (-2, -1),(−2,−1), (1, 2),(1,2), (1, -2),(1,−2), (-1, 2),(−1,2), (-1, -2)(−1,−2)。
我们将使用二维的 dp 和 dp2 来存储我们的数据
方法2:递归+记忆化
用3维数组存放当前深度，当前位置的概率值，递归，如果当前深度和位置已经递归过则直接返回结果，否则对8个位置进行递归后的结果相加，赋值给ans，然后ans/=8，赋值给当前深度的位置值，最后返回该值即可。
692. 前K个高频单词
先用hashmap存放每个元素出现的次数，然后得到一个map.Entry数组表示其map视图（里面存放了每一个key和value值），然后对其排序后再输出即可。
698. 划分为k个相等的子集
先求出元素总和和最大值，如果总和%k不为0或者如果最大值大于总和/k，直接返回false，否则进行回溯法，遍历数组，如果当前剩下子集数为0，返回true，如果当前得到的值和目标值相等，则递归返回，此时的参数中剩下子集数-1，开始位置为0，当前值为0。否则进行for遍历，从开始位置开始，如果当前位置未遍历并且加上该值后当前值小于等于目标值，则标记当前点为已经访问，进行递归判断，如果递归的结果为true，则返回true，否则标记当前点未访问，继续遍历，遍历结束还未找到，则返回false。