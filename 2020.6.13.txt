71. 简化路径
栈存放目录，先用spilt（"/"）将字符串的所有“/”分离，然后遍历字符数组，如果当前字符串为“..”,如果栈不为空，弹出一个元素，如果为".",进行下一个遍历，否则如果不为空，就加入栈中，遍历后如果栈为空，返回/，否则返回/+栈字符组合形式(for遍历栈，不能从后往前弹出，注意顺序。
74. 搜索二维矩阵
将二维数组看成一维的进行二分搜索即可
77. 组合
回溯函数：private void Back(Integer []nums,int curK,int n,int startIndex){},nums是长度为k的数组，curK即是当前找的元素个数也是该回要赋值的nums下标，startIndex为当前函数for循环的开始，n为整数最大值，如果curK=k，就将nums加入结果集，否则从startIndex开始遍历，如果curK+n-i+1<target在，则往后找不到结果，所以从当前i开始就可以不用遍历，直接break，否则nums[curK]=i;然后curK+1，startIndex+1进入下一个循环。
79. 单词搜索
定义一个boolean二维数组，表示该位置是否走过，然后在主方法里遍历原二维数组，如果是第一个元素就调用回溯函数，如果此回溯函数返回为true，直接返回结果，否则继续，最后遍历结束返回false。回溯函数中如果已经找到单词末尾，flag=true，返回true。如果flag=true，返回true。（flag为全局变量）按照上下左右的顺序走，如果其中一个可以走，就将其boolean数组位置变为true，回溯下一个，回溯结束位置变为false。