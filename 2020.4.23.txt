861. 翻转矩阵后的得分
法一：对每一行和每一列依次判断，对于行：第一个元素不为1就翻转，对于列，0个数多与1就翻转
因为任意行或列翻转两次等于没有翻转，故每行每列最多翻转一次
法二：针对每一列进行计算
    public int matrixScore(int[][] A) {
        int R = A.length, C = A[0].length;
        int ans = 0;
        for (int c = 0; c < C; ++c) {
            int col = 0;
            for (int r = 0; r < R; ++r)
                col += A[r][c] ^ A[r][0];//对于第一列为A[r][c] ^ A[r][0]，所以Math.max(col, R - col)令它全为1， (1 << (C-1-c));这是第一列元素对应的二进制数
            ans += Math.max(col, R - col) * (1 << (C-1-c));  //都加起来就得到第一列所有元素之和，从第二列开始计算的就是每一列0的个数
        }//从第二列开始，当 A[r][c] ^ A[r][0]=1时，要么1^0，此时因为第一位为0，所以肯定这一行要翻转，它对应的1其实就是0，要么0^1这时不用翻转，对应的0就是0，所以col算的是0的个数
        return ans;
    }
893. 特殊等价字符串组
该问题的关键是如何把每一个字符串对应的所有特殊等价字符都对应起来
我们可以定义长度为52的int数组，前26个位置存放偶数位a-z出现个数
后26个位置存放奇数位a-z个数，再把该数组转成字符串放入hashset中
最后hashset大小就是结果
537. 复数乘法
就是把复数的实部和虚部提取出来，注意可以用正则表达式，如 String x[] = a.split("\\+|i");
如\\+匹配\+，\+表示出现+号（注意+不能直接用“+”），|表示或逻辑
面试题 17.11. 单词距离
就是每次出现一个对应字符而且另外一个字符出现过，就计算现在的结果与现在结果的差距动态更新结果