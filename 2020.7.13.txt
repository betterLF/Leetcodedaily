面试题 17.13. 恢复空格
字典树，不过此字典树是从单词末尾往前找的。
遍历原单词数组，将其加入字典树中，然后定义dp[n+1]数组，下标处代表前i个元素未标识元素的最小值，遍历未标识字符串，dp[i]=dp[i-1]+1，即初始化i处未标识。然后从下标i-1处开始--遍历，如果当前点不可能为单词最后一个字符，则直接退出该层遍历，即i处不可能为一个单词结尾。如果当前点存在于字典树中并且是一个单词，则 dp[i] = Math.min(dp[i], dp[j]);//其值为前j个结点的结果(即j+1->i-1为一个单词)和现在dp[i]的最小值，如果dp[i]==0,此时已经达到可能到达的最小值，直接退出该层遍历。否则字典树后移继续查找
357. 计算各个位数不同的数字个数
数学计算，从n=3开始，dp[i]=dp[i-1]+9*9*temp（temp=8,n=3,temp=8*7,n=4.......以此类推）
当temp乘到0时直接返回dp[i-1]，因为后面不可能右不重复的了，如果遍历结束没有到0，就返回dp[n]
365. 水壶问题
bfs和dfs均可，每次计算时分清空x,y，加满x，加满y,y向x中倒水，x向y中倒水处理，用hashset存放已经处理过的状态，碰到该状态直接继续即可。最后找到返回true，否则false
368. 最大整除子集
先对数组进行排序，定义一个dp数组，下标代表以当前位置为结尾的子序列的最长长度，初始化每个值都为1，然后定义max=1，为当前遍历到的最长子序列长度和index=0，为当前最长子序列结尾的下标位置，遍历数组，然后从当前位置向前遍历，如果刚好整除则    dp[i]=Math.max(dp[i],dp[j]+1);最后里层循环结束后，看是否更新max和index，最后从index开始，反向得到子序列，如果dp[max]==dp[j]+1并且nums[max]%nums[j]==0，则说明j是前一个元素，将其家人结果集，j--，更新max即可。
