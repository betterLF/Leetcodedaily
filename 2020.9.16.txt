648. 单词替换
前缀树保存词根，如果当前是一个词根，当前树的word为词根，否则为空，遍历句子，对每一个单词从前往后遍历，如果当前前缀树为空或者前缀树的word不为空退出该单词的遍历，对该单词进行判断后加入结果集即可。最后遍历结束返回结果。
649. Dota2 参议院
用两个数组分别存放R和D的人数和淘汰权，先遍历数组，记录R和D的人数，并加入队列，然后只要人数数组两个值都大于0就进行while循环，如果当前队列首部为X，并且对X的淘汰权大于0，则淘汰权--，X人数--，代表该人被淘汰，并且对X的淘汰权少1，否则没有淘汰权，则对X的另外一个淘汰权++，并将该点加入队列，最后看哪队剩余人数返回结果。
650. 只有两个键的键盘
上面已经给了递归的做法，看了 36 个 'A' 的分解之后，我们发现题目要求的就是 36 的所有素因子之和。素因子是指，该因子不可再次拆分。
为什么非得拆解成 素因子 呢？因为当一个因子还可以分解成更小的因子的时候，那么分解后的结果会更小
比如 36 = 18 * 2，题目所求的最优结果是 18 + 2 = 20 么？显然不是，因为如果把18 拆开 36 = 3 * 6 * 2，此时复制粘贴的个数只需要 3 + 6 + 2 = 12 次。但这仍然不是最优结果，36 = 3 * 2 * 3 * 2，此时复制粘贴的个数只需要 3 + 2 + 3 + 2 = 10 次。此时已经是最优了。

具体证明就是要证明 m * n > m + n，等价于求 (m - 1)*(n - 1) > 1，当 m 和 n 大于 2 的时候上式永远成立。

至于代码，就是让我们求 n 能拆成哪些素因子。我们让 d 试探是否为因子从 2 开始递增，如果 n 能被 d 整除时，此时的 d 是 n 的一个素因子，求复制粘贴次数的结果中增加 d ；而且如果 d 是个素因子，那么要一次性把 n 中除掉所有的 d。

作者：fuxuemingzhu
链接：https://leetcode-cn.com/problems/2-keys-keyboard/solution/cong-di-gui-dao-su-shu-fen-jie-by-fuxuemingzhu/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。