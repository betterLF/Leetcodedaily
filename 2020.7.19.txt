400. 第N个数字
定义temp初始化为9,count初始化为1，如果n>0，就一直while循环
如果temp*count>=n，就进行结果计算，先  long div=n/count; long yu=n%count;long start=(int)Math.pow(10,count-1)得到n在当前区域类内的位置，如果余数为0，则n对应的数字为 long  ans=start+div-1;其应该是该数最后一位，如果余数不为0，则为ans=start+div的余数-1位。如果temp*count<n,则temp*=10，count++(即一开始考虑1-9，后来10-99，再后来100-999)
388. 文件的最长绝对路径
初始化一个数组，索引代表第i层的名字长度，初始化第0层为0,   int res=0;//代表当前层的长度，int max=0;//代表当前最大值，int k=0;//代表当前深度，int mark=0;//代表当前是否出现点
遍历字符串，如果当前为\n，则表示到达一层结尾，则下一层depth[k+1]=res+1+deprh[k]，即该层长度
如果mark==1，代表前面出现点，就比较max和depth[k+1]的大小，更新max值。然后把k，mark，res置为0，如果当前点为\t，则k++，否则如果当前点为.，mark=1，无论是否为.，res都++。最后退出循环，为了防止最后一个目录是文件名，则如果mark>0，再比较一次max = Math.max(max, res+1+depth[k]);  
401. 二进制手表
用栈存放当前已经选好的灯亮情况，如果当前栈长度为10，则如果当前1选好了，就进行判断加入结果集。
然后return。如果1全选好了，直接加0，进行dfs。如果1没有全选好，如果当前可以选0，就可以选0后再选1，否则只选1
404. 左叶子之和
递归搜索，如果当前左子树存在并且左子树的左右子树为空，结果加上该值。递归当前结点的左右子树。