面试题15. 二进制中1的个数
每次右移一位和1相与的结果加到结果上即可
面试题 16.07. 最大数值
int arr[]={a,b};
return arr[(int)((long)a-b>>>63)];
a-b为正数时首位为0，即右移63位后为0
a-b为负数时首位为1，即右移63位后为1
260. 只出现一次的数字 III
第一种：HashMap，key为元素值，value为出现次数，遍历map找出value为1的值加入数值即可
第二种：令x=0，x和数组中所有数依次异或，得到的最后结果及只出现一次的两个元素的异或结果（相同元素异或结果为0，抵消）
这时令diff=x&（-x）将x的最右边的1保存，其余为0，这个1就属于其中一个元素m（另外一个为n），这时diff&数组元素为0的那个就是n，因为n为1的数位不可能和diff相同，此时一遍异或操作做下来，得到的结果就是m，再m^diff就是n。
349. 两个数组的交集
两个set分别遍历两个数组加入元素，再使用内置函数  set1.retainAll(set2);//使得set1中保留set2中有的元素，这样set1中的结果就是交集。
1305. 两棵二叉搜索树中的所有元素
两个中序遍历得到两颗树按照大小关系排序的数组
在使用归并排序得到结果
1356. 根据数字二进制下 1 的数目排序
借用面试题15的函数进行Compartor定义，再进行排序即可