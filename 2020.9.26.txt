735. 行星碰撞
定义栈存放行星，定义turn代表是否加入当前行星，初始化为true，如果当前栈不为空并且当前行星小于0，栈顶大于0，则进行判断，如果当前行星值大于栈顶出栈继续下一层循环，如果两者相等，则栈顶出栈，turn为false，最后退出true循环，如果当前turn为true，则加入该行星，最后遍历结束，栈输出为数组即可。
738. 单调递增的数字
首先想到的是，我们总是可以得到一个 d999...9 的候选答案（其中 0 <= d <= 9 后接一些数字9）。例如，如果 n=432543654，我们总是可以得到至少 39999999 的答案。
我们可以进行优化。例如，当数字是 123454321 时，我们可以有一个 123449999 的候选候选答案。这似乎是一个不错的策略，就是采用一个单调递增的前缀，然后在相邻的数字首次下降的索引之前（悬崖）减少这个数字，然后用 9 代替其余的字符。
这种策略什么时候会出错？如果 n=333222，那么我们的策略将给出 332999 的候选答案，但这不是单调递增的。
因此，我们可以修复我们的策略，通过线性扫描成功地变形成最终的答案 332999->329999->299999。
算法：
我们会找到第一个悬崖 s[i-1]>s[i]。然后，当悬崖存在时，我们将减去适当的数字，然后移动 i。再把剩下的数字补上 9，最后完成扫描。
我们可以证明我们的算法是正确的，因为我们每次遇到悬崖时，减少的数字必须至少减少 1。然后，对其余数字的最大的可能选择是全部为 9。

740. 删除与获得点数
用数组存放所有元素出现的次数，定义dp数组表示到当前值时可以得到的最大值，则其转移方程为 dp[i]=Math.max(dp[i - 1], dp[i - 2] + i * all[i]);即当前位置不选和当前位置选的时候的最大值即可。