622. 设计循环队列
循环队列的意思是：循环队列就是将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。在循环队列结构中，当存储空间的最后一个位置已被使用而再要进入队运算时，只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，即将存储空间的第一个位置作为队尾。循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。
在循环队列中，当队列为空时，有front=rear，而当所有队列空间全占满时，也有front=rear。为了区别这两种情况，规定循环队列最多只能有MaxSize-1个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了。因此，队列判空的条件是front=rear，而队列判满的条件是front=（rear+1)%MaxSize。
但是本题的循环队列没有空闲，考虑用数组来记录。
1143. 最长公共子序列
解题思路
最长公共子序列（Longest Common Subsequence，LCS）是指：
给定两个字符串（数列），求一个子列，使得这个子列是两个给定字符串的最长公共部分。例如：
a b c d e f
b d a f
以上两个字符串的LCS就是b d f，接下来用动态规划求解。
形如最大子列和、最长上升子列等动规问题，我们都有一个dp[]数组来表示问题的状态。
例如，在最大子列和问题中，dp[i]表示以nums[i]作为序列末尾时能得到的最大子列和；最长上升子列问题中，dp[i]表示以nums[i]作为序列末尾时能得到的最长上升子列长度。dp[i]就是问题的状态，此外，我们会从题目中获取边界信息，例如dp[0] = nums[0]就是最大子列和问题的边界。然后我们需要写出关键的状态转移方程。之后就可以从边界出发，通过状态转移方程求解状态了。以上是解决动规问题的一般思路。
而本题我们依然会使用一个dp数组表示问题的状态，只不过这次我们用的是二维数组dp[][]。带着疑惑往下看。
我们用dp[i][j]表示第一个字符串的第1至i号位字符部分与第二个字符串的第1至j号位字符部分的LCS长度，即问题的状态。这里我们用1作为字符串第一个字符的下标。以上面给出的两个字符串为例，dp[4][2]的值就是字符串"a b c d"与字符串"b d"的LCS长度，显然为2。理解了dp数组含义后，其实我们要求解的状态就是dp[len1][len2]，len1为第一个字符串的长度，len2为第二个字符串的长度。
详细链接：https://leetcode-cn.com/problems/longest-common-subsequence/solution/marvelzhong-deng-de-xue-xi-bi-ji-1143-by-tyanyon-2/
451. 根据字符出现频率排序
先用StringBuilder存储每个字符出现的串，然后清空数组元素为null的值（加入数组中），最后自己建立排序
    Comparator<StringBuilder> cc=new Comparator() {
           @Override
           public int compare(Object o1, Object o2) {
               return o2.toString().length()-o1.toString().length();
           }
       };（o2-o1为递减排序）
最后排序好的集合加入到StringBuilder中