991. 坏了的计算器
除了对 X 执行乘 2 或 减 1 操作之外，我们也可以对 Y 执行除 2（当 Y 是偶数时）或者加 1 操作。
这样做的动机是我们可以总是贪心地执行除 2 操作：
当 Y 是偶数，如果先执行 2 次加法操作，再执行 1 次除法操作，我们可以通过先执行 1 次除法操作，再执行 1 次加法操作以使用更少的操作次数得到相同的结果 [(Y+2) / 2 vs Y/2 + 1]。
当 Y 是奇数，如果先执行 3 次加法操作，再执行 1 次除法操作，我们可以将其替代为顺次执行加法、除法、加法操作以使用更少的操作次数得到相同的结果 [(Y+3) / 2 vs (Y+1) / 2 + 1]。
算法
当 Y 大于 X 时，如果它是奇数，我们执行加法操作，否则执行除法操作。之后，我们需要执行 X - Y 次加法操作以得到 X。
5404. 用栈操作构建数组
遍历目标数组，如果count（初始化为1）！=当前值，count++，结果集加入push和pop，继续while循环
否则count++；结果集中中加入Push，进行下次遍历
5405. 形成两个异或相等数组的三元组数目
只要当前相异或后值为0，就能构造出a==b，此时满足条件的个数=endIndex-startIndex
5406. 收集树上所有苹果的最少时间

先遍历hasApple集合，把为true的索引加入apple集合中，然后定义一个长度为n的int型数组temp
下标代表结点，值代表父节点。定义一个ArrayList存放走过的结点（因为走过了就可以不用重复走第二次了）如果apple的大小为0，说明没有苹果，返回0
对apple集合进行遍历（如果0也是苹果，从i==1开始，因为0的苹果不需要走路）
设当前苹果结点为c，ans++，如果temp[c]！=0，代表不能到达根节点，c=temp[c后，while循环继续遍历，直到temp[c]==0
期间注意把路径放入集合中已经ans++；
遍历完集合后，因为路径是来回，所以返回2*ans。
