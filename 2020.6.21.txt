1014. 最佳观光组合
定义一个量mx为a[i]+i，表示当前遍历到的前i个位置的最大值，然后遍历数组，结果为当前结果ans与mx+a[j]-j的值，然后动态更新mx。(因为该题i和j处没有联系，只与本身有关，所以可以定下mx)
146. LRU缓存机制
手动实现双向循环链表，并且定义hashmap,key存放关键字，value存放链表结点。
put():每次加入元素时先判断有没有该该元素，有的话直接修改该元素的value值后返回，没有的话，判断是否超过容量，没有超直接加入该元素到链表头部(定义一个方法实现)，超了话就将该链表最后一个元素移除并将该结点加到链表头部即可。
get():如果map里没有该关键字，返回-1，否则移除双向链表的该关键字的结点原先所在位置并加到链表头部。
150. 逆波兰表达式求值
1：栈模拟即可，如果是运算符，取出栈顶两个元素进行操作（注意减法和除法的对应关系），否则将数字存入栈中
2:通过数组来模拟栈
 执行每个运算操作都是类似numStack[index - 2] += numStack[--index];
151. 翻转字符串里的单词
先用String类的trim()去除字符串首尾空格，然后将字符串以空格划分。倒序遍历该字符串，如果当前为空字符串就continue，否则每次都ans.append(cur[i].trim()).append(" ");最后变成字符串再trim一次就行