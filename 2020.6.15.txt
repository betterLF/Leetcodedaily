91. 解码方法
如果子符长度为0，返回0，如果字符长度为1并且值不为0，返回1,否则返回0，否则定义dp数组，如果第一位为0或者第二位为0时第一位大于2，就返回0，因为此时无法编码。否则dp[0]=1,如果前两个字符在21-26或者11-19时dp[1]=2,否则为1，从i=2开始遍历字符串，如果当前字符与前一个字符在21-26,11-19之间，dp[i]=dp[i-1]+dp[i-2];否则如果当前位为0而且前一位大于2或者等于0，无法编码，返回0，如果当前位为0，dp[i]=dp[i-2]，即这两个字符必须在一起。否则dp[i]=dp[i-1]。最后如果退出for循环，返回dp最后一个元素。
92. 反转链表 II
主方法里定义前结点和当前结点，当当前结点到达指定翻转位置时，调用翻转函数，进行翻转，并且将翻转函数的末尾指向原来的末尾，返回翻转链表的头部，接在前结点的后面即可
93. 复原IP地址
回溯函数进行讨论，如果剩余长度超过最大剩余长度或者小于最小剩余长度，直接剪枝，如果当前到达了第4个地址并且字符串走到末尾，遍历栈，拼接字符串加入结果集。否则进行选择，如果当前位置值为0，将其加入stack，直接进行下一个，结束后弹出stack,否则要进行三种可能性的判断即可
95. 不同的二叉搜索树 II
如果n为0，返回空的链表，否则返回回溯函数back(int start,int end)。
回溯函数：新建一个链表c，如果start>end,c.add(null),返回c，否则for循环从start到end,分别求出以当前i为根节点的左右子树 即LinkedList<TreeNode> left = back(start, i - 1);LinkedList<TreeNode> right = back(i + 1, end);，然后里面再来两个for循环，将左右子树的所有可能与当前根节点拼接，加入结果集中，最后返回结果