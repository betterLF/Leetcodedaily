372. 超级次方
欧拉函数(百度)求解，使得b的幂降到最低再进行运算
运算:a%=1337,ans=a,进行b-2次循环，执行ans*=a,ans%=1337,最后返回ans即可。
373. 查找和最小的K对数字
定义优先权队列，存放数组，存放的顺序为nums1[n1[0]]+nums2[n1[1]]-nums1[n2[0]]+nums2[n2[1]]
遍历集合，先将nums1的i和nums2的0放入集合，然后只要队列不为空或者k>0，就取出队首元素，并且将该数组第二个元素+1放入队列中，然后将该队首数组的对应值加入结果集中，k--。这样做的正确性是每次取出的最小值其下一个最小值的可能取值可能是后面放入优先队列中的(即第二个元素增加),或者是第一个元素增加(该元素已经存在于队列中)。
以 ii 为第一次尝试找到最小开销的过程可以被分解为找左右区间内最小开销的子问题。对于每个区间，我们重复问题拆分的过程，得到更多子问题，这启发我们可以用 DP 解决这个问题。

我们需要使用一个 dp 矩阵，其中 dp(i,j) 代表在 (i,j) 中最坏情况下最小开销的代价。现在我们只需要考虑如何求出这个 dp 数组。如果区间只剩下一个数 k ，那么猜中的代价永远为 0 ，因为我们区间里只剩下一个数字，也就是说，所有的 dp(k,k) 都初始化为 0 。然后，对于长度为 2 的区间，我们需要所有长度为 1 的区间的结果。由此我们可以看出，为了求出长度为 len 区间的解，我们需要所有长度为 len-1的解。因此我们按照区间长度从短到长求出 dpd数组。
现在，我们应该按照什么办法来求出 dp矩阵呢？对于每个 dp(i, j)，当前长度为en=j−i+1 。我们遵照方法 1 中俄办法，依次挑选每个数字作为第一次尝试的答案，可以求出最小开销：
但是在计算开销的时候我们有一个便利之处，就是我们已经知道了小于 len 长度 dp数组的所有答案。因此 dp 方程式变成了：int res = piv + Math.max(dp[start][piv - 1], dp[piv + 1][start + len - 1]);
376. 摆动序列
动态规划:
如果当前位置比前一个位置大，则当前位置为上升时的子序列长度=前一个位置下降时的序列长度+1与前一个位置上升时的序列长度的最大值，当前位置为下降时的子序列长度不变。小于同理


