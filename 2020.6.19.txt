133. 克隆图
hashset存放已经创建的克隆结点对应值，hashmap key存放对应结点的值，value存放结点，将原结点加入队列中，进行bfs，取出当前遍历的结点和克隆结点，遍历原结点的邻接表，如果该邻接点未出现过，创建该克隆结点加入hashmap，值加入hashset，并且克隆结点的集合加入该结点即可，直到队列为空，结束
134. 加油站
1：遍历两个数组，如果当前出发点一直加下去可以到达原点，就返回该点，否则进行下一个遍历
2：遍历两个数组，定义总消耗和当前消耗，定义起点为0，如果当前消耗小于0，起点加1，遍历结束，如果总消耗小于0，返回-1，否则返回起点
137. 只出现一次的数字 II
位运算
利用卡洛图得到状态转移方程，设置z为输入(0/1),xy代表此时该位出现了几个1，根据题意针对每个z和xy
得到下一个状态的xy，借此得到xy的状态转移方程，然后分析可知，最后的y就是结果，遍历一遍数组，x和y执行转移即可。

138. 复制带随机指针的链表
1：hashmap存放当前结点和其克隆结点，然后map.get(key).next=map.get(key.next);map.get(key).random=map.get(key.random);分别克隆next域和random域指向
2：先按照原结点-克隆结点-原结点的顺序拼接子串，再将克隆结点的random域指向指定位置（利用每个结点的下一个结点为克隆结点的性质)，最后分离两个链表即可
139. 单词拆分
动态规划：定义一个boolean型dp数组，长度为字符串长度加1，从i=1开始遍历字符串，然后遍历单词表，如果单词表中的某个单词（长度为len）出现在以i位置前一个元素为结尾并且去除该单词后的下标即i-len为true，说明i可以拆分，置为true，退出第二层遍历，进行下一个第一层遍历
层次遍历:将0加入队列中，然后只要队列不空，就取出该下标，如果该下标未被访问过则找到以该下标为出发点的单词，将该单词末尾下标加入队列中，如果末尾刚好达到结点返回true，否则继续遍历下一个，如果最后队列为空，退出循环，则返回false
