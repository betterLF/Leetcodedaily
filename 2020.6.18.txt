1300. 转变数组后最接近目标值的数组和
定义left为1，right为100000，进行二分查找，如果当前mid值为value时<target，left=mid+1，否则right=mid-1；然后如果此时的left和left-1（即潜在的两个可能的解）大于函数最大值，直接返回函数最大值，否则比较left和left-1时域target的绝对值差返回结果
129. 求根到叶子节点数字之和
递归搜索，如果当前结点为null，返回0，说明该层子树值为0，否则上一层结果*10+cur.val得到当前结果，如果当前结点左右子树都为null就返回该结果（说明为叶子结点），否则返回其左右子树分别递归之和
130. 被围绕的区域
bfs搜索当前边缘区域，如果值为O，就bfs搜索，将与此O相连的O都变成o,边缘全都搜索完就遍历原数组，为o就变为O，否则变为X
131. 分割回文串
遍历原字符串，第一个子字符串从1个开始判断，一直到全部字符覆盖进行判断，如果当前为回文子符串，就将当前回文子字符串加入结果集，进行下一次遍历，结束后该字符串出集合，进行下一个可能的判断。