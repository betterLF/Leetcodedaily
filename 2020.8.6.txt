486. 预测赢家
1:递归:定义一个方法，参数为左右区间，当前ab结果值，当前谁先手以及数组
如果左>右，直接返回a是否大于等于b。
如果当前a先手，递归返回取左或者取右的或结果
如果当前b先手，递归返回取左或取右的与结果
2:动态规划(官方题解，但不确定正确)
我们同样可以使用动态规划来解决这个问题。用 dp(i, j) 表示当剩下的数为 nums[i .. j] 时，当前操作的选手（注意，不一定是先手）与另一位选手最多的分数差。当前操作的选手可以选择 nums[i] 并留下 nums[i+1 .. j]，或选择 nums[j] 并留下 nums[i .. j-1]，因此状态转移方程为：
dp(i, j) = max(nums[i] - dp(i+1, j), nums[j] - dp(i, j-1))
dp(i, i) = nums[i]
491. 递增子序列
递归回溯，如果当前遍历到的下标到达数组末尾，判断当前集合长度是否大于等于2，如果满足，加入到结果集中，return。否则如果当前集合为空或者当前下标值大于等于集合最后一个元素，则加入该元素进行递归遍历，结束后将该元素移除，回溯。然后进行判断，如果当前元素和原先末尾元素一样，则直接返回(因为该次遍历会和当前元素末尾不选而选择下一个元素的情况重复)，不进行下一步不加入当前元素的遍历，否则进行下一步
494. 目标和
定义一个二维dp数组，下标i为当前遍历到的点，j表示当前可以得到的值，dp[i][j]表示该值的个数，遍历数组，dp[i][j+nums[i]]+=dp[i-1][j]，dp[i][j-nums[i]]=dp[i-1][j],最后返回dp[len-1][S]即可(因为可能结果值会为负数，所以可以考虑+1000修正)