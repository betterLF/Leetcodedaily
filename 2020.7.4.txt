284. 顶端迭代器
方法1:创建链表集合，存放当前迭代器元素，然后peek()返回list.getFirst()，next()返回list.removeFirst(),hasNext()返回list.size()!=0
方法二:直接用迭代器和一个boolean flag和一个记录值的cur，peek()，如果有下一个元素，则看flag，flag为true，表示前面peek过了，直接返回cur，否则取出下一个元素，赋值给cur，flag赋值为true，返回cur。next()，如果flag为true，代表前面有peek()操作，flag赋值为false，返回cur，否则取出下一个元素返回。hasNext()，返回iterator.hasSet()||flag。
303. 区域和检索 - 数组不可变
定义一个数组和一个dp数组，dp数组用于求前i项和，然后初始化时将dp数组填充完，调用函数时，如果i==0，直接返回dp[j]，否则返回dp[j]-dp[i-1];
326. 3的幂
方法一：常规：只要n大于等于3，就进行while循环，如果n%3!=0,直接返回false，否则n/=3,最后返回n==1,。
方法二:return n > 0 && 1162261467 % n == 0;1162261467是3的19次方，是3在int范围内最大整数，因为3是质数，所以3的19次方可以整除任何3的0次方，3的一次方。。。因此可以通过这种方法得到答案
342. 4的幂
方法1:位运算,    return (num > 0) && ((num & (num - 1)) == 0) && ((num & 0xaaaaaaaa) == 0);
首先num>0判断其是否大于0，num&(num-1)判断其是否是2的倍数，如果其不是2的倍数，则num-1和num肯定都包含一个2的倍数，所以该位会被保留。使得与结果不为0。如果是2的倍数，则num-1后原来num只有一位为1，-1后该位为0，结果为false。最后一个num&0Xaaaaaaaa,因为4的幂是2的偶次幂，所以其与1010101010101010相与肯定为0，而2的奇次幂相与肯定为1，所以可以这样相与
方法二：位运算+数学       return (num > 0) && ((num & (num - 1)) == 0) && (num % 3 == 1);
因为2的奇次幂%3==2,2的偶次幂%3==1，所以直接得到结果(数学推导)